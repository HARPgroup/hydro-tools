#' Time Series data object
#' @description Object for storing single time series value
#' @details Has standard methods for managing data and meta data
#' @importFrom R6 R6Class  
#' @param datasource optional RomDataSource for remote and local storage
#' @param config list of attributes to set
#' @return reference class of type openmi.om.base.
#' @seealso NA
#' @examples NA
#' @export RomProperty
RomProperty <- R6Class(
  "RomProperty",
  inherit = RomEntity,
  public = list(
    #' @field base_entity_type kind of entity
    base_entity_type = 'dh_properties',
    #' @field pk_name the name of this entity's pk column
    pk_name = 'pid',
    #' @field pid unique ID in this RomDataSource
    pid = NA,
    #' @field featureid id of entity this is attached to
    featureid = NA,
    #' @field entity_type type of entity this is attached to
    entity_type = NA,
    #' @field propname locally unique name
    propname = NA,
    #' @field startdate begin timestamp
    startdate = NA,
    #' @field enddate end time stamp
    enddate = NA,
    #' @field propvalue numerical value
    propvalue = NA,
    #' @field propcode alphanumeric value
    propcode = NA,
    #' @field proptext alphanumeric value
    proptext = NA,
    #' @field data_matrix json matrix
    data_matrix = NA,
    #' @field varid variable ID from RomDataSource
    varid = NA,
    #' @field bundle (for future use)
    bundle = NA,
    #' @field uid user id of creator
    uid = NA,
    #' @field modified timestamp 
    modified = NA,
    #' @field datasource RomDataSource
    datasource = NA,
    #' @field sql_select_from syntax to use to select via an odbc or other SQL based datasource
    sql_select_from = "
      select * from (
        select a.*, b.proptext_value as proptext, 
          CASE
            WHEN c.field_dh_matrix_value IS NOT NULL THEN php_unserialize_to_json(c.field_dh_matrix_value )
            WHEN d.field_projection_table_value IS NOT NULL THEN php_unserialize_to_json(d.field_projection_table_value )
            ELSE NULL
          END as data_matrix
        from dh_properties as a 
        left outer join field_data_proptext as b
        on (
          b.entity_id = a.pid
          and b.entity_type = 'dh_properties'
        )
        left outer join field_data_field_dh_matrix as c
        on (
          c.entity_id = a.pid
          and c.entity_type = 'dh_properties'
        )
        left outer join field_data_field_projection_table as d
        on (
          d.entity_id = a.pid
          and d.entity_type = 'dh_properties'
        )
      ) as dh_properties
    ",
    #' @return get_id the id of this entity alias to remote pkid, subclassed as function
    get_id = function() {
      return(self$pid)
    },
    #' @param site URL of some RESTful repository
    #' @param config list of attributes to set, see also: to_list() for format
    #' @param load_remote automatically query REST data source for matches?
    #' @return object instance
    initialize = function(datasource = NULL, config = list(), load_remote = FALSE) {
      # a config template can be generated by using the to_list() method 
      # of a blank object
      # todo: some of this can be handled by the RomDataSource?
      stopifnot(class(datasource)[[1]] == "RomDataSource")
      self$datasource <- datasource 
      config <- self$handle_config(config)
      # if requested, we try to load
      # only the last one returned will be sent back to user if multiple
      if (load_remote) {
        prop <- self$datasource$get_prop(config, 'list', TRUE, self)
        #print((nrow(prop) >= 1))
        if (is.data.frame(prop)) {
          if (nrow(prop) >= 1) {
            prop <- as.list(prop[1,])
          } else {
            prop <- FALSE
          }
        }
        # merge config with prop
        #message("Found")
        if (!is.logical(prop)) {
          config <- prop
        }
      }
      self$load_data(config, load_remote)
    },
    #' @param config 
    #' @returns an updated config if necessary or FALSE if it fails
    handle_config = function(config) {
      config_cols <- names(config)
      if (is.element("varkey", config_cols)) {
        if (!is.null(self$datasource)) {
          vardef = self$datasource$get_vardef(config$varkey)
          config$varid = vardef$varid
          # eliminate this since if passed raw to rest will cause problems
          config$varkey <- NULL
        }
      }
      return(config)
    },
    #' @param config list of attributes to set, see also: to_list() for format
    #' @return NULL
    from_list = function(config) {
      for (i in names(config)) {
        if (i == "pid") {
          self$pid = as.integer(as.character(config$pid))
        } else if (i == "varid") {
          self$varid = as.integer(as.character(config$varid))
        } else if (i == "entity_type") {
          self$entity_type = as.character(config$entity_type)
        } else if (i == "featureid") {
          self$featureid = as.integer(as.character(config$featureid))
        } else if (i == "propname") {
          self$propname = as.character(config$propname)
        } else if (i == "startdate") {
          self$startdate = as.integer(as.character(config$startdate))
        } else if (i == "enddate") {
          self$enddate = as.integer(as.character(config$enddate))
        } else if (i == "propvalue") {
          self$propvalue = as.numeric(as.character(config$propvalue))
        } else if (i == "propcode") {
          self$propcode = as.character(config$propcode)
        } else if (i == "proptext") {
          # adding proptext support now.
          self$proptext = as.character(config$proptext)
        } else if (i == "bundle") {
          self$bundle = as.character(config$bundle)
        } else if (i == "data_matrix") {
          if (is.character(config$data_matrix)) {
            mvalid <- jsonlite::validate(config$data_matrix)
            if (mvalid[1] == TRUE) {
              drupal_data = jsonlite::fromJSON(config$data_matrix)
              data_header <- drupal_data$tabledata[[1]]
              n <- 1
              for (h in data_header) {
                if(is.null(h) | is.na(h)) {
                  data_header[[n]] <- paste0("V",n)
                }
                n <- n + 1
              }
              data_table <- as.data.frame(data_header)
              for (i in 2:length(drupal_data$tabledata)) {
                raw_row <- drupal_data$tabledata[[i]]
                drow <- as.data.frame(drupal_data$tabledata[[i]])
                data_table <- rbind(data_table, drow)
              }
              self$data_matrix = data_table
            } else {
              # it is either valid, or empty either way, assign it
              self$data_matrix <- config$data_matrix
            }
          }
        }
      }
    },
    #' @return list of object attributes suitable for input to new() and from_list() methods
    to_list = function() {
      # returns as a list, which can be set and fed back to 
      # from_list() or new(config)
      t_list <- list(
        pid = as.integer(as.character(self$pid)),
        entity_type = as.character(self$entity_type),
        varid = as.integer(as.character(self$varid)),
        bundle = as.character(self$bundle),
        featureid = as.integer(as.character(self$featureid)),
        propname = as.character(self$propname),
        startdate = as.character(self$startdate),
        enddate = as.character(self$enddate),
        propvalue = as.numeric(as.character(self$propvalue)),
        proptext = as.character(self$proptext),
        propcode = as.character(self$propcode)
        # todo
        #modified = self$modified,
        # todo:
        #tlid = self$tlid,
        # todo:
        # uid = self$uid
        # todo:
        # bundle = self$bundle
      )
      if (is.character(self$data_matrix)) {
        mvalid <- jsonlite::validate(self$data_matrix)
        if (mvalid[1] == TRUE) {
          t_list$data_matrix = jsonlite::toJSON(self$data_matrix)
        }
      }
      if (is.null(self$bundle)) {
        self$bundle <- 'dh_properties'
      }
      if (!nchar(self$bundle) > 0) {
        self$bundle <- 'dh_properties'
      }
      return(t_list)
    },
    #' @param name attribute name
    #' @param value attribute value
    #' @param format type of data being sent (default, json, ...)
    #' @return object instance
    set_prop = function(name, value, format='default') {
      # this should be at the base class, should not have to subclass
      # @tbd: can this even be done on a local object field? 
      # it may not be necessary, we may only implement 
      # calls to set RomProperties linked to it?
      # self$hair <- val
    },
    #' @param push_remote whether to automatically propagate changes to remote data source
    #' @return boolean TRUE on success, FALSE on failure
    save = function(push_remote=FALSE) {
      # object class responsibilities
      # - know the required elemenprop such as varid, featureid, entity_type
      #   fail if these required elemenprop are not available 
      if (push_remote) {
        pl <- self$to_list()
        if (!is.Date(pl$startdate) & !is.integer(pl$startdate)) {
          # remove 
          pl[[which(names(pl) == 'startdate')]] <- NULL
        }
        if (!is.Date(pl$enddate) & !is.integer(pl$enddate)) {
          # remove 
          pl[[which(names(pl) == 'enddate')]] <- NULL
        }
        pid = self$datasource$post('dh_properties', 'pid', pl)
        if (!is.logical(pid)) {
          self$pid = pid
        }
      }
      self$datasource$set_prop(self$to_list())
    }
  )
)


