#' Time Series data object
#' @description Object for storing single time series value
#' @details Has standard methods for managing data and meta data
#' @importFrom R6 R6Class  
#' @param datasource optional RomDataSource for remote and local storage
#' @param config list of attributes to set
#' @return reference class of type openmi.om.base.
#' @seealso NA
#' @examples NA
#' @export RomProperty
RomProperty <- R6Class(
  "RomProperty",
  inherit = RomEntity,
  public = list(
    #' @field base_entity_type kind of entity
    base_entity_type = 'dh_properties',
    #' @field pk_name the name of this entity's pk column
    pk_name = 'pid',
    #' @field pid unique ID in this RomDataSource
    pid = NA,
    #' @field featureid id of entity this is attached to
    featureid = NA,
    #' @field entity_type type of entity this is attached to
    entity_type = NA,
    #' @field has_vardef is pluggable?
    has_vardef = TRUE,
    #' @field propname locally unique name
    propname = NA,
    #' @field startdate begin timestamp
    startdate = NA,
    #' @field enddate end time stamp
    enddate = NA,
    #' @field propvalue numerical value
    propvalue = NA,
    #' @field propcode alphanumeric value
    propcode = NA,
    #' @field proptext alphanumeric value
    proptext = NA,
    #' @field data_matrix json matrix
    data_matrix = NA,
    #' @field varid variable ID from RomDataSource
    varid = NA,
    #' @field bundle (for future use)
    bundle = NA,
    #' @field uid user id of creator
    uid = NA,
    #' @field vid current revision (pk in dh_properties_revision)
    vid = NA,
    #' @field module related module (optional?) 
    module = NA,
    #' @field modified timestamp 
    modified = NA,
    #' @field datasource RomDataSource
    datasource = NA,
    #' @field tree_loaded - this is a switch to enable fast loading of export tree from local storage
    tree_loaded = FALSE,
    #' @field sql_select_from syntax to use to select via an odbc or other SQL based datasource
    sql_select_from = "
      select * from dh_properties_fielded
    ",
    #' @return get_id the id of this entity alias to remote pkid, subclassed as function
    get_id = function() {
      return(self$pid)
    },
    #' @param site URL of some RESTful repository
    #' @param config list of attributes to set, see also: to_list() for format
    #' @param load_remote automatically query REST data source for matches?
    #' @return object instance
    initialize = function(datasource = NULL, config = list(), load_remote = FALSE) {
      # a config template can be generated by using the to_list() method 
      # of a blank object
      # todo: some of this can be handled by the RomDataSource?
      stopifnot(class(datasource)[[1]] == "RomDataSource")
      self$datasource <- datasource 
      config <- self$handle_config(config)
      # if requested, we try to load
      # only the last one returned will be sent back to user if multiple
      if (load_remote) {
        prop <- self$datasource$get_prop(config, 'list', TRUE, self)
        if (is.data.frame(prop)) {
          if (nrow(prop) >= 1) {
            prop <- as.list(prop[1,])
          } else {
            prop <- FALSE
          }
        }
        # merge config with prop
        #message("Found")
        if (!is.logical(prop)) {
          config <- prop
        }
      }
      self$load_data(config, load_remote)
      if (!is.logical(self$plugin$entity_bundle)) {
        self$bundle = self$plugin$entity_bundle
      } else {
        self$bundle = 'dh_properties'
      }
    },
    #' @param config 
    #' @returns an updated config if necessary or FALSE if it fails
    handle_config = function(config) {
      config = self$insure_varid(config)
      return(config)
    },
    #' @param config list of attributes to set, see also: to_list() for format
    #' @return NULL
    from_list = function(config) {
      for (i in names(config)) {
        if (i == "pid") {
          self$pid = as.integer(as.character(config$pid))
        } else if (i == "vid") {
          self$vid = as.integer(as.character(config$vid))
        } else if (i == "varid") {
          self$varid = as.integer(as.character(config$varid))
        } else if (i == "entity_type") {
          self$entity_type = as.character(config$entity_type)
        } else if (i == "featureid") {
          self$featureid = as.integer(as.character(config$featureid))
        } else if (i == "propname") {
          self$propname = as.character(config$propname)
        } else if (i == "startdate") {
          self$startdate = as.integer(as.character(config$startdate))
        } else if (i == "enddate") {
          self$enddate = as.integer(as.character(config$enddate))
        } else if (i == "propvalue") {
          self$propvalue = as.numeric(as.character(config$propvalue))
        } else if (i == "propcode") {
          self$propcode = as.character(config$propcode)
        } else if (i == "proptext") {
          # adding proptext support now.
          self$proptext = as.character(config$proptext)
        } else if (i == "bundle") {
          self$bundle = as.character(config$bundle)
        } else if (i == "data_matrix") {
          if (is.character(config$data_matrix)) {
            mvalid <- jsonlite::validate(config$data_matrix)
            if (mvalid[1] == TRUE) {
              raw_data = jsonlite::fromJSON(config$data_matrix)
              if ("tabledata" %in% names(raw_data)) {
                data_header <- raw_data$tabledata[[1]]
                n <- 1
                for (h in data_header) {
                  if(is.null(h) | is.na(h)) {
                    data_header[[n]] <- paste0("V",n)
                  }
                  n <- n + 1
                }
                data_table <- as.data.frame(data_header)
                if (length(raw_data$tabledata) > 1) {
                  for (i in 2:length(raw_data$tabledata)) {
                    raw_row <- raw_data$tabledata[[i]]
                    drow <- as.data.frame(raw_data$tabledata[[i]])
                    data_table <- rbind(data_table, drow)
                  }
                }
                if ('weight' %in% names(data_table)) {
                  data_table$weight <- NULL
                }
                names(data_table) <- NULL
              } else {
                data_table = raw_data
              }
              self$data_matrix = data_table
            } else {
              # it is either valid, or empty either way, assign it
              self$data_matrix <- config$data_matrix
            }
          }
        }
      }
    },
    #' @return list of object attributes suitable for input to new() and from_list() methods
    to_list = function() {
      # returns as a list, which can be set and fed back to 
      # from_list() or new(config)
      t_list <- list(
        pid = as.integer(as.character(self$pid)),
        vid = as.integer(as.character(self$vid)),
        module = as.character(self$module),
        entity_type = as.character(self$entity_type),
        varid = as.integer(as.character(self$varid)),
        bundle = as.character(self$bundle),
        featureid = as.integer(as.character(self$featureid)),
        propname = as.character(self$propname),
        startdate = as.character(self$startdate),
        enddate = as.character(self$enddate),
        propvalue = as.numeric(as.character(self$propvalue)),
        proptext = as.character(self$proptext),
        propcode = as.character(self$propcode)
        # todo
        #modified = self$modified,
        # todo:
        #tlid = self$tlid,
        # todo:
        # uid = self$uid
        # todo:
        # bundle = self$bundle
      )
      if (is.list(self$data_matrix)) {
        t_list$data_matrix = as.character(jsonlite::toJSON(self$data_matrix))
      }
      if (is.null(self$bundle)) {
        self$bundle <- 'dh_properties'
      }
      if (!nchar(self$bundle) > 0) {
        self$bundle <- 'dh_properties'
      }
      return(t_list)
    },
    #' @param name attribute name
    #' @param value attribute value
    #' @param format type of data being sent (default, json, ...)
    #' @return object instance
    set_prop = function(name, value, format='default') {
      # this should be at the base class, should not have to subclass
      # @tbd: can this even be done on a local object field? 
      # it may not be necessary, we may only implement 
      # calls to set RomProperties linked to it?
      # self$hair <- val
    },
    #' @param push_remote whether to automatically propagate changes to remote data source
    #' @return boolean TRUE on success, FALSE on failure
    save = function(push_remote=FALSE) {
      # object class responsibilities
      # - know the required elemenprop such as varid, featureid, entity_type
      #   fail if these required elemenprop are not available 
      if (push_remote) {
        pl <- self$to_list()
        if (!is.Date(pl$startdate) & !is.integer(pl$startdate)) {
          # remove 
          pl[[which(names(pl) == 'startdate')]] <- NULL
        }
        if (!is.Date(pl$enddate) & !is.integer(pl$enddate)) {
          # remove 
          pl[[which(names(pl) == 'enddate')]] <- NULL
        }
        vl <- pl
        # if this is an insert, add into revisions 
        if (is.na(pl$vid)) {
          vl$vid <- NULL # removes it from list
        } else {
          if (! (pl$vid > 0)) {
            vl$vid <- NULL # removes it from list
          }
        }
        pid = self$datasource$post('dh_properties', 'pid', pl)
        if (!is.logical(pid)) {
          self$pid = pid
          vl$pid = pid
        }
        # if this is ODBC, we need to manage the revisions
        # also, if we transition to *another* REST, we may also have to do so
        if (self$datasource$connection_type == 'odbc') {
          vid = self$datasource$post('dh_properties_revision', 'vid', vl)
          if (is.na(self$vid)) {
            self$vid = vid
            # set back the revision ID
            status = self$datasource$post('dh_properties', 'pid', list(pid=pid, vid=vid))
          }
        }
        # otherwise, update revisions, especially now that we are no longer 
        # dooing revisions.  THis is likely *not* important as drupal is 
        # the only thing that needs revisions, but since drupal will break if 
        # an entity lacks a revision, it is important in case we ever have to spin
        # it back up.
        # insert into dh_properties_revision (
        #   pid,propname,propcode,propvalue,startdate,featureid,entity_type,
        #   bundle,varid,status,module,uid,modified) 
        # select pid,propname,propcode,propvalue,startdate,featureid,entity_type,
        #   bundle,varid,status,module,uid,modified from dh_properties 
        # where pid = 7685242 RETURNING vid;
        # Returns 8332550, alternative, look for revision:
        #    select vid from dh_properties_revision where pid = 7685242;
        # update dh_properties set vid = 8332550 where pid = 7685242;
      }
      self$datasource$set_prop(self$to_list())
    },
    #' @param delete_remote update locally only or push to remote database
    #' @return NULL
    delete = function(delete_remote=FALSE) {
      # object class responsibilities
      # - know the required elemenprop such as varid, featureid, entity_type
      #   fail if these required elemenprop are not available 
      if (delete_remote) {
        finfo <- self$to_list()
        # we pass the pid, since if there are multiple revisions it will delete all
        fid = self$datasource$delete('dh_properties_revision', 'pid', finfo)
      }
      super$delete(delete_remote)
    }
  )
)


